# ADR-004: Turbo 모노레포 구조 채택

## 상태
승인됨 (2025-09-21)

## 컨텍스트
미니 노션 프로젝트의 코드베이스 구조 결정이 필요했습니다. 프론트엔드, 백엔드, 공통 라이브러리, 타입 정의 등 여러 패키지를 효율적으로 관리하고, 팀 협업 및 CI/CD 최적화를 위한 구조가 요구되었습니다.

**주요 요구사항**:
- 프론트엔드/백엔드 코드 공유 최적화
- 타입 안전성 보장 (공통 타입 정의)
- 빠른 빌드 및 테스트 실행
- 독립적인 패키지 배포 가능
- 개발자 경험 최적화
- CI/CD 파이프라인 효율성

**제약사항**:
- 팀 크기 고려 (5-10명)
- 빌드 시간 최소화 필요
- 의존성 관리 복잡성 제어
- 배포 독립성 보장

## 결정
**Turbo + pnpm 워크스페이스** 기반 모노레포 구조 채택

## 고려된 옵션들

### 옵션 1: 멀티레포 (별도 저장소)
**장점**:
- 완전한 독립성 및 격리
- 팀별 독립적 개발 가능
- 배포 파이프라인 단순화
- 권한 관리 세밀화

**단점**:
- 코드 중복 및 동기화 문제
- 타입 정의 공유 복잡성
- 버전 관리 및 호환성 이슈
- 크로스 패키지 리팩토링 어려움
- CI/CD 복잡성 증가

### 옵션 2: Lerna 모노레포
**장점**:
- 성숙한 모노레포 도구
- npm 패키지 발행 최적화
- 버전 관리 자동화

**단점**:
- 빌드 캐싱 기능 부족
- 느린 빌드 성능
- 복잡한 설정 및 학습 곡선
- 현대적 도구 대비 기능 부족

### 옵션 3: Nx 모노레포
**장점**:
- 강력한 빌드 캐싱
- 의존성 그래프 시각화
- 다양한 프레임워크 지원
- 코드 생성 도구

**단점**:
- 복잡한 설정 및 학습 곡선
- 과도한 기능 (오버엔지니어링)
- 벤더 락인 위험
- 작은 팀에는 과도한 복잡성

### 옵션 4: Turbo + pnpm (선택됨)
**장점**:
- 초고속 빌드 캐싱
- 간단한 설정 및 사용법
- pnpm의 효율적 의존성 관리
- 점진적 도입 가능
- 뛰어난 개발자 경험

**단점**:
- 상대적으로 새로운 도구
- 일부 고급 기능 부족
- 커뮤니티 생태계 제한적

## 결정 근거

### 1. 빌드 성능 최적화
**Turbo 캐싱 시스템**:
- 로컬 캐시: 이전 빌드 결과 재사용
- 원격 캐시: 팀 간 빌드 결과 공유
- 증분 빌드: 변경된 패키지만 빌드
- 병렬 실행: 의존성 그래프 기반 최적화

```json
// turbo.json 설정 예시
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"]
    },
    "test": {
      "dependsOn": ["build"],
      "inputs": ["src/**/*.tsx", "src/**/*.ts"]
    }
  }
}
```

**성능 개선 결과**:
- 초기 빌드: ~5분 → 캐시 적중 시: ~30초
- 테스트 실행: ~3분 → 캐시 적중 시: ~10초
- CI/CD 파이프라인: 50% 시간 단축

### 2. pnpm 의존성 관리
**효율적 패키지 관리**:
- 심볼릭 링크 기반 중복 제거
- 엄격한 의존성 해결 (phantom dependencies 방지)
- 빠른 설치 속도 (npm 대비 2-3배)
- 디스크 공간 절약 (50-70% 절약)

```yaml
# pnpm-workspace.yaml
packages:
  - 'apps/*'
  - 'packages/*'
  - 'tools/*'
```

### 3. 코드 공유 최적화
**패키지 구조**:
```
packages/
├── shared/          # 공통 타입 및 유틸리티
├── ui/              # 재사용 가능한 UI 컴포넌트
└── contracts/       # OpenAPI 스펙 및 생성된 타입
```

**타입 안전성 보장**:
- 프론트엔드/백엔드 간 타입 공유
- OpenAPI 스펙에서 자동 타입 생성
- 컴파일 타임 타입 검증

### 4. 개발자 경험 최적화
**통합 개발 환경**:
```bash
# 전체 프로젝트 개발 서버 실행
pnpm dev

# 특정 앱만 실행
pnpm dev --filter=web

# 전체 테스트 실행 (캐싱 적용)
pnpm test

# 변경된 패키지만 빌드
pnpm build --filter=...[HEAD^]
```

**Hot Module Replacement**:
- 패키지 간 변경사항 즉시 반영
- 공통 라이브러리 수정 시 앱 자동 리로드
- 개발 중 타입 변경 실시간 반영

### 5. CI/CD 최적화
**병렬 처리**:
- 독립적인 패키지 병렬 빌드/테스트
- 의존성 그래프 기반 최적 실행 순서
- 실패한 패키지만 재실행

**캐시 전략**:
- GitHub Actions 캐시 통합
- 원격 캐시로 팀 간 빌드 결과 공유
- 브랜치별 캐시 격리

## 결과 및 영향

### 긍정적 결과
- **개발 속도 향상**: 빌드 시간 70% 단축
- **코드 품질 개선**: 공통 타입으로 타입 안전성 보장
- **유지보수성**: 중앙화된 의존성 관리
- **CI/CD 효율성**: 파이프라인 실행 시간 50% 단축
- **개발자 경험**: 간단한 명령어로 전체 프로젝트 관리

### 부정적 결과 및 위험
- **초기 설정 복잡성**: 모노레포 구조 설계 및 설정 시간
- **의존성 충돌**: 패키지 간 버전 충돌 가능성
- **빌드 복잡성**: 의존성 그래프 관리 복잡성
- **저장소 크기**: 단일 저장소 크기 증가
- **권한 관리**: 세밀한 접근 권한 제어 어려움

### 완화 방안
- **점진적 마이그레이션**: 기존 프로젝트를 단계적으로 모노레포로 이전
- **의존성 정책**: 공통 의존성 버전 통일 정책 수립
- **문서화**: 모노레포 사용법 및 베스트 프랙티스 문서화
- **모니터링**: 빌드 성능 및 캐시 효율성 지속적 모니터링
- **백업 전략**: 패키지별 독립 배포 가능한 구조 유지

## 관련 결정
- [ADR-001: NestJS vs Next.js 백엔드 선택](./001-nestjs-vs-nextjs.md) - 백엔드 패키지 구조
- [ADR-002: React 19 + Vite 프론트엔드 조합](./002-react19-vite.md) - 프론트엔드 빌드 통합
- [ADR-006: 다층 테스트 전략 수립](./006-testing-strategy.md) - 모노레포 테스트 전략

## 참고 자료
- [Turbo 공식 문서](https://turbo.build/repo/docs)
- [pnpm 워크스페이스 가이드](https://pnpm.io/workspaces)
- [모노레포 vs 멀티레포 비교](https://blog.nrwl.io/misconceptions-about-monorepos-monorepo-vs-polyrepo-c347b5a1b1e6)
- [Turbo 성능 벤치마크](https://turbo.build/repo/docs/benchmarks)
- [모노레포 베스트 프랙티스](https://monorepo.tools/)