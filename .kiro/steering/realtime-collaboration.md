---
inclusion: fileMatch
fileMatchPattern: "**/collaboration/**"
---

# 실시간 협업 개발 가이드

Y.js 기반 실시간 협업 기능 구현을 위한 패턴과 표준을 정의합니다. 모든 협업 관련 코드는 이 가이드를 따라야 합니다.

## Y.js + Tiptap 통합 패턴

### 필수 통합 구성 요소
- **Y.Doc**: 문서 상태를 관리하는 CRDT 데이터 구조
- **HocuspocusProvider**: WebSocket 기반 실시간 동기화 제공자
- **IndexeddbPersistence**: 오프라인 지원을 위한 로컬 영속화
- **Collaboration Extension**: Tiptap과 Y.js 연결 확장
- **CollaborationCursor Extension**: 실시간 커서 표시 확장

### 설정 구조 원칙
```typescript
// 협업 설정 인터페이스 표준
interface CollaborationConfig {
  documentId: string;    // 문서 고유 식별자
  userId: string;        // 사용자 고유 식별자  
  userName: string;      // 표시용 사용자 이름
  userColor: string;     // 커서/선택 영역 색상
  websocketUrl: string;  // Hocuspocus 서버 URL
}
```

### Tiptap 확장 설정 규칙
- **Collaboration 확장**: Y.Doc과 연결, 필드명 명시 필수
- **CollaborationCursor 확장**: 사용자 정보 포함 필수
- **Provider 정리**: 컴포넌트 언마운트 시 destroy() 호출 필수
- **메모이제이션**: Provider 생성 시 useMemo 사용 권장

## Hocuspocus 서버 확장 방법

### 필수 확장 구성
- **Logger Extension**: 모든 협업 활동 로깅 필수
- **Redis Extension**: 다중 서버 환경 동기화 필수
- **Database Extension**: Y.Doc 영속화 필수
- **Authentication Hook**: JWT 기반 인증 및 권한 검사 필수

### 서버 설정 원칙
```typescript
// 기본 서버 구성 요소
Server.configure({
  port: number,           // 환경변수로 포트 설정
  extensions: [           // 확장 기능 배열
    Logger,              // 로깅
    Redis,               // 다중 서버 동기화  
    Database,            // 영속화
  ],
  onAuthenticate,        // JWT 인증 로직
  onConnect,             // 연결 시 처리
  onDisconnect,          // 연결 해제 시 처리
});
```

### 커스텀 확장 개발 규칙
- **Extension 인터페이스** 구현 필수
- **비동기 처리**: 모든 확장 메서드는 async/await 사용
- **에러 처리**: try-catch로 예외 상황 처리 필수
- **로깅**: 모든 중요 이벤트 로그 기록 필수

### 인증 및 권한 검사 표준
- **JWT 토큰 검증**: 모든 연결에서 토큰 유효성 확인
- **문서 접근 권한**: 사용자별 문서 접근 권한 검증
- **에러 처리**: 인증 실패 시 명확한 에러 메시지 제공

## Awareness와 Presence 구현 표준

### UserPresence 데이터 구조 표준
```typescript
interface UserPresence {
  id: string;           // 사용자 고유 식별자
  name: string;         // 표시용 사용자 이름
  color: string;        // 커서/선택 영역 색상
  cursor?: {            // 커서 위치 (선택사항)
    anchor: number;
    head: number;
  };
  selection?: {         // 선택 영역 (선택사항)
    from: number;
    to: number;
  };
  lastSeen: number;     // 마지막 활동 시간 (타임스탬프)
}
```

### Awareness 상태 관리 원칙
- **실시간 업데이트**: Awareness 변경 시 즉시 UI 반영
- **자동 정리**: 비활성 사용자 자동 제거 (타임아웃 기반)
- **상태 동기화**: 로컬 상태 변경 시 즉시 다른 클라이언트에 전파
- **메모리 관리**: 사용자 맵 적절한 크기 유지

### 커서 및 선택 영역 표시 규칙
- **색상 일관성**: 사용자별 고유 색상 유지
- **시각적 구분**: 커서와 선택 영역 명확히 구분
- **성능 최적화**: 불필요한 리렌더링 방지
- **접근성**: 색상 외 추가 시각적 단서 제공

### 사용자 활동 추적
- **lastSeen 업데이트**: 모든 사용자 활동 시 타임스탬프 갱신
- **비활성 사용자 처리**: 일정 시간 후 자동 제거
- **연결 상태 표시**: 온라인/오프라인 상태 시각적 표시

## WebSocket 연결 관리 및 재연결 로직

### 연결 상태 타입 정의
```typescript
type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';
```

### 연결 상태 관리 원칙
- **상태 추적**: 연결, 연결됨, 연결 해제, 에러 상태 구분
- **재시도 카운터**: 재연결 시도 횟수 추적 및 제한
- **이벤트 기반**: Provider 이벤트 리스너로 상태 변경 감지
- **정리 작업**: 컴포넌트 언마운트 시 이벤트 리스너 제거

### 자동 재연결 전략
- **지수 백오프**: 재연결 간격을 점진적으로 증가 (1초 → 2초 → 4초...)
- **최대 시도 횟수**: 5회 제한 후 재연결 중단
- **정상 종료 구분**: WebSocket 코드 1000 (정상 종료) 시 재연결 안함
- **사용자 알림**: 재연결 상태를 사용자에게 시각적으로 표시

### 연결 복구 처리
- **수동 재연결**: 사용자가 수동으로 재연결 시도 가능
- **상태 초기화**: 성공적 재연결 시 재시도 카운터 리셋
- **에러 로깅**: 연결 실패 시 상세 에러 정보 로그 기록
- **Graceful Degradation**: 오프라인 상태에서도 기본 편집 기능 유지

## 충돌 해결 및 동기화 패턴

### Y.js CRDT 충돌 해결 원칙
- **자동 병합**: 동시 편집 시 사용자 개입 없이 자동 충돌 해결
- **타임스탬프 기반**: 변경사항의 시간 순서에 따른 우선순위 결정
- **클라이언트 ID 기반**: 동일 시간 변경 시 클라이언트 ID로 결정적 해결
- **의미 보존**: 사용자 의도를 최대한 보존하는 방향으로 병합

### 원격 업데이트 처리 규칙
- **Origin 구분**: 로컬 vs 원격 업데이트 구분하여 처리
- **사용자 알림**: 원격 변경사항 발생 시 적절한 사용자 알림 제공
- **변경 추적**: 문서 변경 이력 로깅 및 추적
- **충돌 로깅**: 복잡한 충돌 상황 발생 시 상세 로그 기록

### 동기화 상태 모니터링 요구사항
```typescript
// 동기화 상태 인터페이스
interface SyncStatus {
  isSynced: boolean;        // 완전 동기화 여부
  pendingUpdates: number;   // 대기 중인 업데이트 수
  lastSyncTime: number;     // 마지막 동기화 시간
}
```

### 동기화 품질 보장
- **실시간 상태 표시**: 동기화 진행 상황 사용자에게 표시
- **대기 업데이트 추적**: 전송 중인 업데이트 수 모니터링
- **동기화 완료 확인**: 모든 변경사항 서버 반영 확인
- **네트워크 지연 처리**: 느린 네트워크 환경에서도 안정적 동작

## Y.Doc 영속화 전략

### 데이터베이스 스키마 설계 원칙
- **바이너리 저장**: Y.Doc 상태를 Bytes 타입으로 PostgreSQL에 저장
- **버전 관리**: 문서 변경 시마다 버전 번호 증가
- **메타데이터 분리**: 제목, 생성자 등 메타데이터는 별도 필드로 관리
- **스냅샷 테이블**: 정기적 백업을 위한 별도 스냅샷 테이블 운영

### 영속화 서비스 요구사항
```typescript
// 영속화 서비스 인터페이스
interface PersistenceService {
  saveDocument(documentId: string, ydocState: Uint8Array): Promise<void>;
  loadDocument(documentId: string): Promise<Uint8Array | null>;
  createSnapshot(documentId: string, userId: string): Promise<void>;
}
```

### 백업 및 복구 정책
- **정기 스냅샷**: 6시간마다 활성 문서 자동 스냅샷 생성
- **증분 백업**: 변경된 문서만 선별적 백업
- **버전 히스토리**: 문서별 변경 이력 추적 및 보관
- **복구 메커니즘**: 스냅샷 기반 문서 상태 복구 기능

### 성능 최적화 고려사항
- **압축**: Y.Doc 바이너리 데이터 압축 저장
- **인덱싱**: 문서 ID, 업데이트 시간 기반 인덱스 설정
- **배치 처리**: 다중 문서 저장 시 배치 처리로 성능 향상
- **캐싱**: 자주 접근하는 문서는 Redis 캐싱 활용

## 성능 최적화 패턴

### 메모리 관리 전략
- **크기 모니터링**: Y.Doc 메모리 사용량 주기적 체크 (1분 간격)
- **임계값 설정**: 10MB 초과 시 경고 및 최적화 작업 수행
- **가비지 컬렉션**: 불필요한 히스토리 데이터 정리
- **메모리 누수 방지**: Provider 및 이벤트 리스너 적절한 정리

### 네트워크 최적화 설정
- **압축 활성화**: WebSocket 메시지 압축으로 대역폭 절약
- **배치 처리**: 짧은 시간 내 다중 업데이트 배치로 전송
- **재연결 타임아웃**: 적절한 타임아웃 설정으로 불필요한 재연결 방지
- **메시지 큐잉**: 연결 불안정 시 메시지 큐잉으로 데이터 손실 방지

### 렌더링 성능 최적화
- **가상화**: 대용량 문서에서 가상 스크롤링 적용
- **디바운싱**: 빈번한 상태 업데이트 디바운싱 처리
- **메모이제이션**: 불필요한 컴포넌트 리렌더링 방지
- **지연 로딩**: 필요한 시점에만 협업 기능 초기화

## 에러 처리 및 복구

### 에러 분류 및 처리 전략
- **연결 에러**: 네트워크 문제, 서버 다운 등 연결 관련 오류
- **인증 에러**: JWT 토큰 만료, 권한 부족 등 인증 관련 오류  
- **문서 에러**: 문서 없음, 접근 권한 없음 등 문서 관련 오류
- **동기화 에러**: 데이터 충돌, 버전 불일치 등 동기화 관련 오류

### 사용자 친화적 에러 메시지
```typescript
// 에러 타입별 메시지 매핑
const ERROR_MESSAGES = {
  'connection-error': '서버 연결에 실패했습니다. 네트워크를 확인해주세요.',
  'authentication-failed': '인증에 실패했습니다. 다시 로그인해주세요.',
  'document-not-found': '문서를 찾을 수 없습니다.',
  'sync-error': '동기화 중 오류가 발생했습니다. 새로고침을 시도해주세요.',
};
```

### 복구 메커니즘
- **자동 재시도**: 일시적 오류에 대한 자동 재시도 로직
- **수동 복구**: 사용자가 수동으로 복구 작업 수행 가능
- **상태 초기화**: 심각한 오류 시 협업 상태 완전 초기화
- **오프라인 모드**: 네트워크 오류 시 오프라인 편집 모드 전환

### 에러 로깅 및 모니터링
- **상세 로깅**: 모든 에러 상황에 대한 상세 로그 기록
- **에러 추적**: 에러 발생 패턴 분석 및 추적
- **알림 시스템**: 심각한 에러 발생 시 개발팀 알림
- **복구 통계**: 에러 복구 성공률 모니터링

이 가이드를 따르면 안정적이고 확장 가능한 실시간 협업 기능을 구현할 수 있습니다.