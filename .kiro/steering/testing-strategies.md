---
inclusion: fileMatch
fileMatchPattern: "**/*.test.*"
---

# 다층 테스트 아키텍처 전략

미니 노션 프로젝트의 포괄적인 테스트 전략을 정의합니다. 각 테스트 레벨별 목적, 범위, 실행 조건을 명확히 하여 안정적이고 신뢰할 수 있는 시스템을 구축합니다.

## 테스트 피라미드 구조

```
        E2E Tests (적음)
      ─────────────────
    Integration Tests (보통)
   ─────────────────────────
  Contract Tests (보통)
 ───────────────────────────
Unit Tests (많음)
```

**핵심 원칙**: 빠르고 안정적인 테스트를 많이, 느리고 불안정한 테스트는 최소한으로 작성합니다.

## 1. 단위 테스트 (Unit Tests)

### 목적 및 범위
- **개별 함수/컴포넌트의 격리된 동작 검증**
- 비즈니스 로직의 정확성 보장
- 빠른 피드백 루프 제공
- 리팩토링 안전성 확보

### 테스트 대상
- **프론트엔드**: React 컴포넌트, 커스텀 훅, 유틸리티 함수, Zustand 스토어
- **백엔드**: 서비스 로직, 유틸리티 함수, 도메인 모델, 데이터 변환 로직
- **공통**: packages/shared의 모든 로직

### 실행 조건
- **개발 중**: 파일 저장 시 자동 실행 (Watch 모드)
- **CI/CD**: 모든 커밋에서 실행
- **배포 전**: 필수 통과 조건

### 작성 원칙
- **AAA 패턴**: Arrange, Act, Assert 구조 준수
- **단일 책임**: 하나의 테스트는 하나의 동작만 검증
- **독립성**: 테스트 간 의존성 없이 독립적 실행
- **명확한 네이밍**: 테스트 의도가 명확히 드러나는 이름 사용
- **모킹 최소화**: 실제 구현체 사용을 우선하되, 외부 의존성만 모킹

### 커버리지 목표
- **핵심 비즈니스 로직**: 90% 이상
- **유틸리티 함수**: 95% 이상
- **UI 컴포넌트**: 80% 이상 (주요 상호작용 중심)

## 2. Contract 테스트 (API Contract Tests)

### 목적 및 범위
- **API 스펙과 실제 구현 간 일치성 검증**
- 프론트엔드-백엔드 간 계약 보장
- API 변경사항의 호환성 검증
- 병렬 개발 지원

### 테스트 전략
- **Prism Mock Server**: OpenAPI 스펙 기반 목 서버 활용
- **Contract-First 개발**: `packages/contracts/openapi/*.yaml`에 스펙 작성 필수
- **openapi-typescript**: 스펙에서 TypeScript 타입 자동 생성
- **양방향 검증**: 요청/응답 모두 스펙 준수 확인
- **버전 호환성**: API 변경 시 하위 호환성 검증

### 실행 조건
- **개발 중**: API 스펙 변경 시 자동 실행
- **통합 테스트 전**: Contract 검증 후 통합 테스트 진행
- **배포 전**: API 호환성 필수 검증

### 검증 항목
- **요청 스키마**: 파라미터, 헤더, 바디 구조 검증
- **응답 스키마**: 상태 코드, 응답 구조, 데이터 타입 검증
- **에러 응답**: 예외 상황별 응답 형식 검증
- **인증/권한**: 보안 요구사항 준수 검증

## 3. 통합 테스트 (Integration Tests)

### 목적 및 범위
- **시스템 컴포넌트 간 상호작용 검증**
- 실제 데이터베이스와의 연동 테스트
- 외부 서비스 통합 검증
- 엔드투엔드 데이터 플로우 확인

### TestContainers 활용 전략
- **실제 데이터베이스**: PostgreSQL 컨테이너로 실제 DB 환경 구성
- **Redis 캐싱**: Redis 컨테이너로 캐싱 로직 검증
- **격리된 환경**: 각 테스트마다 독립적인 컨테이너 환경
- **데이터 일관성**: 트랜잭션 롤백으로 테스트 간 격리

### 실행 조건
- **로컬 개발**: 주요 기능 완성 후 수동 실행
- **CI/CD**: Pull Request 생성 시 자동 실행
- **배포 전**: 필수 통과 조건

### 테스트 범위
- **데이터베이스 연동**: Prisma ORM을 통한 CRUD 작업, 트랜잭션, 제약조건 검증
- **캐싱 로직**: Redis 7+ ioredis를 통한 캐시 저장/조회/무효화 검증
- **실시간 협업**: @hocuspocus/server와 Y.js 문서 동기화 및 충돌 해결 검증
- **인증/권한**: NestJS Guards를 통한 JWT 토큰 생성/검증, 권한 기반 접근 제어

### 성능 고려사항
- **컨테이너 재사용**: 가능한 경우 컨테이너 재사용으로 실행 시간 단축
- **병렬 실행**: 독립적인 테스트는 병렬로 실행
- **리소스 정리**: 테스트 완료 후 컨테이너 자동 정리

## 4. E2E 테스트 (End-to-End Tests)

### 목적 및 범위
- **실제 사용자 시나리오 검증**
- 전체 시스템의 통합된 동작 확인
- 사용자 경험 품질 보장
- 핵심 비즈니스 플로우 검증

### Playwright + Cucumber BDD 전략
- **BDD 시나리오**: 비즈니스 요구사항을 자연어로 표현
- **Given-When-Then**: 명확한 테스트 시나리오 구조
- **페이지 객체 모델**: 재사용 가능한 페이지 상호작용 추상화
- **크로스 브라우저**: Chrome, Firefox, Safari 지원

### 실행 조건
- **로컬 개발**: 주요 기능 완성 후 수동 실행
- **스테이징**: 배포 전 자동 실행
- **프로덕션**: 배포 후 스모크 테스트 실행

### 핵심 시나리오
- **사용자 인증**: 회원가입, 로그인, 로그아웃 플로우
- **블록 기반 편집**: Tiptap 에디터에서 블록 생성, 편집, 삭제, 드래그 앤 드롭 순서 변경
- **슬래시 커맨드**: `/` 입력으로 블록 타입 선택 및 생성
- **실시간 협업**: Y.js CRDT 기반 다중 사용자 동시 편집 시나리오
- **워크스페이스 관리**: 계층적 페이지 구조, 권한 설정, 문서 공유

### BDD 시나리오 예시 구조
```gherkin
Feature: 실시간 문서 협업
  As a 팀 멤버
  I want to 다른 사용자와 동시에 문서를 편집하고 싶다
  So that 효율적인 협업이 가능하다

  Scenario: 두 사용자가 동시에 문서 편집
    Given 사용자 A와 B가 같은 문서에 접속해 있다
    When 사용자 A가 텍스트 블록을 추가한다
    And 사용자 B가 다른 위치에 헤딩 블록을 추가한다
    Then 두 사용자 모두에게 변경사항이 실시간으로 반영된다
    And 충돌 없이 두 블록이 모두 저장된다
```

## 테스트 실행 전략

### 개발 워크플로우
1. **TDD 사이클**: Red → Green → Refactor 패턴 준수
2. **단위 테스트 우선**: 새 기능 개발 시 단위 테스트부터 작성
3. **점진적 통합**: 단위 → Contract → 통합 → E2E 순서로 테스트 확장

### CI/CD 파이프라인
```
커밋 → 단위 테스트 → Contract 테스트 → 통합 테스트 → E2E 테스트 → 배포
```

### 실행 시간 목표
- **단위 테스트**: 전체 실행 5분 이내
- **Contract 테스트**: 전체 실행 3분 이내
- **통합 테스트**: 전체 실행 15분 이내
- **E2E 테스트**: 핵심 시나리오 30분 이내

## 테스트 데이터 관리

### 테스트 데이터 전략
- **Fixture 파일**: 재사용 가능한 테스트 데이터 정의
- **Factory 패턴**: 동적 테스트 데이터 생성
- **시드 데이터**: 통합/E2E 테스트용 기본 데이터셋
- **데이터 격리**: 테스트 간 데이터 오염 방지

### 민감 정보 처리
- **개인정보 마스킹**: 실제 사용자 데이터 사용 금지
- **더미 데이터**: 가상의 사용자/문서 데이터 사용
- **환경 분리**: 테스트 환경과 프로덕션 환경 완전 분리

## 테스트 품질 관리

### 코드 리뷰 체크리스트
- [ ] 테스트 의도가 명확한가?
- [ ] 적절한 테스트 레벨을 선택했는가?
- [ ] 테스트가 독립적으로 실행되는가?
- [ ] 예외 상황도 적절히 테스트하는가?
- [ ] 테스트 실행 시간이 적절한가?

### 테스트 메트릭
- **커버리지**: 라인/브랜치/함수 커버리지 추적
- **실행 시간**: 테스트 실행 시간 모니터링
- **안정성**: 테스트 실패율 및 Flaky 테스트 추적
- **유지보수성**: 테스트 코드 복잡도 관리

## 도구 및 라이브러리

### 단위 테스트
- **Vitest**: 빠른 실행과 Jest 호환성
- **Testing Library**: 사용자 중심 테스트 작성
- **MSW**: API 모킹 및 네트워크 요청 처리

### 통합 테스트
- **TestContainers**: 실제 데이터베이스 환경 구성
- **Supertest**: HTTP API 테스트
- **Vitest**: 테스트 러너 및 어설션 (Jest API 호환)

### E2E 테스트
- **Playwright**: 크로스 브라우저 자동화
- **Cucumber**: BDD 시나리오 작성
- **Allure**: 테스트 리포트 생성

## 테스트 환경 구성

### 로컬 개발 환경
- **Docker Compose**: 통합 테스트용 서비스 구성
- **Watch 모드**: 파일 변경 시 자동 테스트 실행
- **병렬 실행**: 멀티코어 활용한 빠른 테스트 실행

### CI/CD 환경
- **컨테이너 기반**: 일관된 테스트 환경 보장
- **캐싱**: 의존성 및 빌드 결과 캐싱으로 실행 시간 단축
- **병렬 실행**: 테스트 스위트별 병렬 실행

이 테스트 전략을 통해 안정적이고 신뢰할 수 있는 미니 노션 시스템을 구축할 수 있습니다. 각 테스트 레벨의 목적을 명확히 하고, 적절한 도구와 전략을 사용하여 효율적인 테스트 자동화를 달성합니다.