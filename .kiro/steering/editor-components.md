---
inclusion: fileMatch
fileMatchPattern: "**/editor/**"
---

# Tiptap 기반 에디터 컴포넌트 개발 가이드

미니 노션의 블록 기반 에디터 시스템 개발을 위한 포괄적인 가이드라인입니다. Tiptap과 Y.js를 활용한 실시간 협업 에디터의 아키텍처 원칙과 구현 패턴을 정의합니다.

## 블록 기반 에디터 아키텍처

### 핵심 설계 원칙

**독립적인 블록 구조**
- 각 블록은 독립적인 ProseMirror 노드로 구현
- 블록 간 의존성 최소화로 재사용성 극대화
- 블록별 고유한 스키마와 렌더링 로직 분리
- 중첩 가능한 블록 구조 지원 (리스트, 인용문 등)

**블록 타입 시스템**
- 텍스트 블록: paragraph, heading (h1-h6), quote
- 리스트 블록: bulletList, orderedList, taskList
- 미디어 블록: image, video, file
- 구조 블록: divider, codeBlock, table
- 인터랙티브 블록: callout, toggle, embed

**블록 상태 관리**
- 각 블록의 메타데이터는 노드 속성으로 저장
- 블록 ID를 통한 고유 식별 및 참조 시스템
- 블록 레벨 실행 취소/다시 실행 지원
- 블록별 포커스 상태 및 선택 영역 관리

### 컴포넌트 구조 패턴

**블록 컴포넌트 계층**
```
BlockWrapper (공통 래퍼)
├── BlockHandle (드래그 핸들)
├── BlockContent (실제 콘텐츠)
│   ├── TextBlock
│   ├── HeadingBlock  
│   ├── ListBlock
│   └── MediaBlock
└── BlockActions (블록별 액션 메뉴)
```

**Props 인터페이스 표준화**
- 모든 블록 컴포넌트는 일관된 Props 구조 준수
- node, pos, editor 등 ProseMirror 기본 Props 포함
- 블록별 커스텀 속성은 node.attrs를 통해 전달
- 이벤트 핸들러는 명명 규칙 통일 (onUpdate, onDelete, onFocus)

**렌더링 최적화**
- React.memo를 활용한 불필요한 리렌더링 방지
- 블록 내용 변경 시에만 해당 블록만 업데이트
- 가상화된 렌더링으로 대용량 문서 성능 보장
- 지연 로딩을 통한 초기 렌더링 시간 단축

## 슬래시 커맨드 구현 패턴

### 커맨드 시스템 아키텍처

**Suggestion 확장 기반 구현**
- @tiptap/suggestion 확장을 기반으로 슬래시 커맨드 구현
- 트리거 문자 `/`로 커맨드 팔레트 활성화
- 키보드 네비게이션 및 검색 필터링 지원
- 커맨드 실행 후 자동 정리 및 포커스 관리

**커맨드 등록 시스템**
- 중앙화된 커맨드 레지스트리로 확장성 보장
- 카테고리별 커맨드 그룹핑 (텍스트, 미디어, 구조)
- 동적 커맨드 로딩으로 번들 크기 최적화
- 권한 기반 커맨드 필터링 지원

**커맨드 메타데이터 구조**
- 커맨드 ID, 제목, 설명, 아이콘 정보
- 검색 키워드 및 별칭 지원
- 실행 조건 및 컨텍스트 검증 로직
- 키보드 단축키 매핑 정보

### 사용자 경험 최적화

**인터랙션 패턴**
- 타이핑 중단 시 자동 커맨드 팔레트 표시
- 방향키를 통한 직관적인 커맨드 선택
- Enter/Tab 키로 커맨드 실행
- Escape 키로 커맨드 팔레트 취소

**시각적 피드백**
- 커맨드 팔레트의 부드러운 애니메이션
- 선택된 커맨드의 명확한 하이라이트
- 커맨드 실행 중 로딩 상태 표시
- 에러 발생 시 사용자 친화적 메시지

**성능 고려사항**
- 커맨드 검색 결과의 디바운싱 처리
- 가상 스크롤링으로 많은 커맨드 효율적 렌더링
- 자주 사용하는 커맨드의 우선순위 정렬
- 커맨드 실행 히스토리 기반 개인화

## 커스텀 노드/마크 생성 방법

### 노드 개발 가이드라인

**노드 스키마 정의**
- ProseMirror 스키마 규칙 준수
- 노드 속성(attrs)을 통한 메타데이터 저장
- 콘텐츠 모델 정의로 허용되는 자식 노드 제한
- 파싱 및 직렬화 규칙 명확히 정의

**React 컴포넌트 통합**
- NodeViewRenderer를 통한 React 컴포넌트 렌더링
- 컴포넌트 생명주기와 ProseMirror 상태 동기화
- 이벤트 처리 및 상태 업데이트 패턴 표준화
- 에러 바운더리를 통한 안정성 보장

**노드 동작 정의**
- 키보드 단축키 및 입력 규칙 정의
- 드래그 앤 드롭 동작 구현
- 복사/붙여넣기 시 노드 변환 로직
- 실행 취소/다시 실행 지원

### 마크 개발 가이드라인

**마크 스타일링**
- CSS-in-JS 또는 Tailwind 클래스 활용
- 마크 중첩 시 스타일 우선순위 관리
- 다크/라이트 테마 대응 스타일링
- 인쇄 및 내보내기 시 스타일 호환성

**마크 상호작용**
- 마크 토글 및 제거 로직 구현
- 마크 속성 편집 인터페이스 제공
- 마크 범위 확장/축소 동작 정의
- 키보드 단축키를 통한 빠른 마크 적용

**접근성 고려사항**
- 스크린 리더를 위한 적절한 ARIA 레이블
- 키보드만으로 마크 조작 가능하도록 구현
- 색상에만 의존하지 않는 시각적 구분
- 고대비 모드 지원

## 가상 스크롤링 최적화

### 성능 최적화 전략

**렌더링 최적화**
- 뷰포트 기반 블록 렌더링으로 메모리 사용량 최소화
- 스크롤 위치에 따른 동적 블록 로딩/언로딩
- 블록 높이 추정을 통한 스크롤바 정확도 향상
- 스크롤 이벤트 디바운싱으로 성능 개선

**메모리 관리**
- 화면 밖 블록의 DOM 노드 제거
- 이미지 및 미디어 콘텐츠의 지연 로딩
- 블록 캐싱 전략으로 재렌더링 비용 절약
- 가비지 컬렉션 최적화를 위한 참조 관리

**스크롤 동작 최적화**
- 부드러운 스크롤 애니메이션 구현
- 스크롤 위치 복원 및 북마크 기능
- 키보드 네비게이션과 스크롤 동기화
- 터치 디바이스 최적화된 스크롤 처리

### 대용량 문서 처리

**점진적 로딩**
- 문서 초기 로딩 시 첫 화면만 렌더링
- 사용자 스크롤에 따른 추가 콘텐츠 로딩
- 백그라운드에서 다음 섹션 미리 로딩
- 로딩 상태의 스켈레톤 UI 제공

**검색 및 네비게이션**
- 전체 문서 인덱싱으로 빠른 검색 지원
- 목차 기반 빠른 섹션 이동
- 검색 결과 하이라이트 및 스크롤 이동
- 브라우저 뒤로/앞으로 버튼 지원

## 마크다운 변환 규칙

### 입력 변환 패턴

**실시간 마크다운 변환**
- 타이핑 중 마크다운 문법 자동 감지
- 스페이스바 입력 시 블록 타입 변환
- 백스페이스로 마크다운 변환 취소
- 마크다운 문법과 리치 텍스트 혼용 지원

**지원 마크다운 문법**
- 헤딩: # ## ### #### ##### ######
- 리스트: - * + (불순서), 1. 2. 3. (순서)
- 체크리스트: - [ ] - [x]
- 인용문: > 
- 코드블록: ``` 언어명
- 인라인 코드: `코드`
- 강조: **굵게** *기울임* ~~취소선~~

**변환 규칙 우선순위**
- 블록 레벨 변환이 인라인 변환보다 우선
- 중첩된 마크다운 문법의 올바른 파싱
- 이스케이프 문자 처리 및 리터럴 텍스트 보존
- 잘못된 문법에 대한 관대한 파싱

### 내보내기 변환

**마크다운 직렬화**
- ProseMirror 문서를 표준 마크다운으로 변환
- 커스텀 블록의 마크다운 표현 정의
- 메타데이터 보존을 위한 프론트매터 활용
- 이미지 및 파일 링크의 상대/절대 경로 처리

**호환성 보장**
- CommonMark 표준 준수
- GitHub Flavored Markdown 확장 지원
- 다른 에디터와의 호환성 테스트
- 가져오기/내보내기 시 데이터 손실 최소화

## 접근성 고려사항

### 키보드 네비게이션

**포커스 관리**
- 논리적인 탭 순서로 모든 요소 접근 가능
- 블록 간 이동을 위한 화살표 키 지원
- 블록 내부와 블록 간 포커스 구분
- 포커스 표시자의 명확한 시각적 구분

**키보드 단축키**
- 표준 에디터 단축키 지원 (Ctrl+B, Ctrl+I 등)
- 블록 조작을 위한 커스텀 단축키 정의
- 단축키 충돌 방지 및 우선순위 관리
- 단축키 도움말 및 가이드 제공

**스크린 리더 지원**
- 의미론적 HTML 구조 사용
- ARIA 레이블 및 설명 적절히 제공
- 블록 타입 및 상태 정보 음성 안내
- 편집 모드와 읽기 모드 구분

### 시각적 접근성

**색상 및 대비**
- WCAG 2.1 AA 기준 색상 대비 준수
- 색상에만 의존하지 않는 정보 전달
- 다크 모드 및 고대비 모드 지원
- 색맹 사용자를 위한 색상 선택

**텍스트 가독성**
- 충분한 줄 간격 및 문자 간격
- 사용자 정의 폰트 크기 지원
- 읽기 모드에서의 최적화된 타이포그래피
- 긴 텍스트의 적절한 줄바꿈 처리

**모션 및 애니메이션**
- 사용자 설정에 따른 애니메이션 감소
- 필수적이지 않은 모션 효과 제거 옵션
- 깜빡임 및 번쩍임 효과 방지
- 부드러운 전환 효과로 사용자 경험 향상

## 에디터 상태 관리

### 상태 아키텍처

**계층적 상태 구조**
- 전역 에디터 상태 (문서 메타데이터, 설정)
- 문서 레벨 상태 (콘텐츠, 선택 영역, 히스토리)
- 블록 레벨 상태 (포커스, 편집 모드, 로컬 상태)
- UI 상태 (툴바, 사이드바, 모달 등)

**상태 동기화**
- ProseMirror 상태와 React 상태 동기화
- Y.js 문서 상태와 로컬 상태 일치성 보장
- 실시간 협업 시 상태 충돌 해결
- 오프라인/온라인 상태 전환 처리

**성능 최적화**
- 상태 변경 시 최소한의 컴포넌트만 리렌더링
- 무거운 계산의 메모이제이션 활용
- 상태 업데이트 배칭으로 성능 향상
- 불필요한 상태 구독 방지

## 에러 처리 및 복구

### 에러 처리 전략

**에러 바운더리**
- 블록 레벨 에러 바운더리로 격리
- 에러 발생 시 해당 블록만 폴백 UI 표시
- 에러 정보 수집 및 로깅
- 사용자 친화적 에러 메시지 제공

**데이터 복구**
- 자동 저장을 통한 작업 내용 보호
- 로컬 스토리지 백업 및 복구 메커니즘
- 문서 버전 히스토리를 통한 이전 상태 복원
- 충돌 해결 및 데이터 병합 로직

**사용자 피드백**
- 에러 발생 시 명확한 상황 설명
- 복구 가능한 액션 제안
- 진행 상황 표시 및 예상 시간 안내
- 도움말 및 지원 연결 링크 제공

이 가이드라인을 따라 개발하면 사용자 친화적이고 성능이 우수한 블록 기반 에디터를 구축할 수 있습니다. 각 원칙은 미니 노션의 핵심 가치인 실시간 협업과 확장 가능한 아키텍처를 지원하도록 설계되었습니다.